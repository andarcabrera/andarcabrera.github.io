<!DOCTYPE html>
<html>
<head>
  <title>Enumerators - Map Method</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="blog.css">
  <link href='http://fonts.googleapis.com/css?family=Indie+Flower' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700&subset=latin,cyrillic-ext' rel='stylesheet' type='text/css'>
</head>
<body>
  <div>
      <h1 class="blogtext" id="blogtitle">Enumerables<span><a href="../website/index1.html">HOME</a></span></h1>
      <h2> The map method</h2>
      <h2>June 12, 2015</h2>
      <p>The Enumerable module is shared by many objects in Ruby, more notably by collection objects. Most of the querying functionality for arrays, hashes and other collection objects stem from this module. At the core of the Enumerable method is the <i>each</i> method, which yields items to a block, one at a time. Many other methods are built starting from the basic each method, and the one I'll talk about today is the <i> map </i> method</p>
      <p>The map methods (a.k.a <i> collect method</i>) is one of the most important enumerable operations. It always returns an array, regardless of what collection object it starts with and the return array always contains the same amount of elements as the original object. For example, see map applied to an array below:
        <ul>
          <li> pets = %w{Basil Ficus Hazel Tara} <br>
          => ["Basil", "Ficus", "Hazel", "Tara"]<br>
          pets.map{|name| name.swapcase}<br>
          => ["bASIL", "fICUS", "hAZEL", "tARA"]<br>
          The new array has 4 elements, each corresponding to the elements in the original array after they were passed through the block and the swapcase method was applied to each element in turn.
      </li><br>
      <li>A shorter version for the map method is using &: in lieu of the block as in: <br>
        pets.map(&:downcase)<br>
        => ["basil", "ficus", "hazel", "tara"]<br></li>
        </ul>
        </p>
      <p>Map always results in a new object, thus it is a non-destructive method. If you need to change the original array in place you would need to use <i> map!</i>, it's destructive counterpart:
        <ul>
          <li> pets.map!(&:upcase)<br>
            => ["BASIL", "FICUS", "HAZEL", "TARA"]<br>
            The resulting array is not a new array in this case, but the original one was modified in place.
          </li> </ul>
          <p>When the block does not provide a method and enumerator is returned instead:</p>
          <ul>
          <li>pets.map<br>
          => #Enumerator: ["Basil", "Ficus", "Hazel", "Tara"]></li><br>
          </ul>
          <p>Here are a couple more examples of the map method being used with other collection objects other than arrays:<br></p>
            <ul>
              <li>Range - it results in an array<br>
                > (1..5).map {|i| i*2}<br>
                => [2, 4, 6, 8, 10]</li><br>
                <li>Hash - prepared to be shock: it results in an array! In this case the result is a nested array with each sub-array being a key-value pair from the hash.<br>
                  >{"x"=>1, "y"=>2, "z"=>3}<br>
                  > hash.map{|k,v| [k,v*2]}<br>
                  => [["x", 2], ["y", 4], ["z", 6]]</li><br>
            </ul></li>
        </p>
      <p>In conclusion, the map array offers a lot of functionality and it is important to remember map is non-destructive, while map! is destructive and they both always result in arrays.</p>
    </div>
</body>
</html>

